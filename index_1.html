<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Production Line Tolerance Optimizer</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background: #f0f0f0;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .header {
            background: #2c3e50;
            color: white;
            padding: 20px;
            text-align: center;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        
        .section {
            margin-bottom: 30px;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 8px;
            background: #fafafa;
        }
        
        .project-field {
            background: #e8f4f8;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            border: 2px solid #3498db;
        }
        
        .project-field label {
            display: block;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .project-field input {
            width: 300px;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 16px;
        }
        
        button {
            background: #3498db;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
            transition: background-color 0.2s;
        }
        
        button:hover {
            background: #2980b9;
        }
        
        button:focus {
            outline: 2px solid #3498db;
            outline-offset: 2px;
        }
        
        button:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
        }
        
        .success-btn {
            background: #27ae60;
        }
        
        .success-btn:hover {
            background: #219a52;
        }
        
        .optimize-btn {
            background: #e74c3c;
            font-size: 16px;
            padding: 15px 30px;
        }
        
        .optimize-btn:hover {
            background: #c0392b;
        }
        
        .loading {
            opacity: 0.6;
            pointer-events: none;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        
        th, td {
            padding: 12px;
            text-align: center;
            border: 1px solid #ddd;
        }
        
        th {
            background: #34495e;
            color: white;
        }
        
        tr:hover {
            background-color: #f8f9fa;
        }
        
        input[type="text"] {
            width: 120px;
            padding: 6px;
            border: 1px solid #ddd;
            border-radius: 4px;
            text-align: center;
        }
        
        input[type="number"] {
            width: 80px;
            padding: 8px;
            border: 2px solid #ecf0f1;
            border-radius: 6px;
            text-align: center;
        }
        
        input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }
        
        input:invalid {
            border-color: #e74c3c;
            background-color: #fdf2f2;
        }
        
        select {
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 3px;
        }
        
        .controls {
            margin: 15px 0;
        }
        
        .controls button {
            margin-right: 10px;
        }
        
        .result, .warning, .error, .info {
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
            position: relative;
        }
        
        .result {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .warning {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }
        
        .error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        
        .info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .optimization-strategy {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 2px solid #6c757d;
        }

        .optimization-results-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 25px;
            border-radius: 12px;
            margin-bottom: 20px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
        }

        .optimization-summary {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .summary-metric {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            backdrop-filter: blur(10px);
        }

        .summary-metric h4 {
            margin: 0 0 10px 0;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
            opacity: 0.9;
        }

        .summary-metric .value {
            font-size: 24px;
            font-weight: bold;
            margin: 5px 0;
        }

        .scale-breakdown {
            background: white;
            color: #333;
            padding: 20px;
            border-radius: 8px;
            margin-top: 20px;
        }

        .scale-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 0;
            border-bottom: 1px solid #eee;
        }

        .scale-row:last-child {
            border-bottom: none;
        }

        .scale-name {
            font-weight: bold;
            color: #2c3e50;
        }

        .scale-details {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .tolerance-value {
            font-size: 18px;
            font-weight: bold;
            padding: 6px 12px;
            border-radius: 20px;
            background: #ecf0f1;
            color: #2c3e50;
        }

        .min-req-status {
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
        }

        .req-met {
            background: #27ae60;
            color: white;
        }

        .req-not-met {
            background: #e74c3c;
            color: white;
        }

        .optimization-timestamp {
            text-align: right;
            font-size: 12px;
            opacity: 0.8;
            margin-top: 15px;
        }

        .results-actions {
            margin-top: 15px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .strategy-option {
            margin-bottom: 15px;
            padding: 10px;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            background: white;
        }

        .strategy-option label {
            display: block;
            cursor: pointer;
            font-weight: bold;
        }

        .strategy-option input[type="radio"] {
            margin-right: 10px;
        }

        .strategy-description {
            font-size: 13px;
            color: #666;
            margin-top: 5px;
            margin-left: 25px;
            line-height: 1.4;
        }

        .tolerance-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .scale-card {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            transition: transform 0.2s;
        }
        
        .scale-card:hover {
            transform: translateY(-2px);
        }
        
        .scale-card h3 {
            margin-top: 0;
            text-align: center;
        }
        
        .metric {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #ecf0f1;
        }

        .min-tolerance-section {
            background: #f0f8ff;
            border: 2px solid #3498db;
            border-radius: 8px;
            padding: 20px;
            margin-top: 20px;
        }

        .min-tolerance-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .min-tolerance-item {
            background: white;
            padding: 15px;
            border-radius: 6px;
            border: 2px solid #ddd;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .min-tolerance-input {
            width: 100%;
            padding: 10px;
            border: 2px solid #ccc;
            border-radius: 4px;
            font-size: 16px;
            margin-top: 8px;
        }
        
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-left: 5px;
        }
        
        .status-success {
            background-color: #27ae60;
        }
        
        .status-error {
            background-color: #e74c3c;
        }
        
        .progress-bar {
            width: 100%;
            height: 4px;
            background-color: #ecf0f1;
            border-radius: 2px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .progress-fill {
            height: 100%;
            background-color: #3498db;
            transition: width 0.3s ease;
        }
        
        .locked-row {
            background-color: #fef9e7 !important;
            border-left: 4px solid #f39c12;
        }
        
        .lock-button {
            padding: 4px 8px;
            font-size: 12px;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .lock-button.locked {
            background-color: #f39c12;
            color: white;
        }
        
        .lock-button.unlocked {
            background-color: #95a5a6;
            color: white;
        }
        
        .lock-button:hover {
            opacity: 0.8;
        }
        
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }
        
        .skip-link {
            position: absolute;
            top: -40px;
            left: 6px;
            background: #000;
            color: #fff;
            padding: 8px;
            text-decoration: none;
            border-radius: 4px;
        }
        
        .skip-link:focus {
            top: 6px;
        }

        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        @keyframes slideOut {
            from { transform: translateX(0); opacity: 1; }
            to { transform: translateX(100%); opacity: 0; }
        }

        @media (max-width: 768px) {
            .container {
                margin: 10px;
                padding: 15px;
            }
            
            .tolerance-cards {
                grid-template-columns: 1fr;
            }
            
            .min-tolerance-grid {
                grid-template-columns: 1fr;
            }
            
            table {
                font-size: 14px;
            }
            
            input[type="text"], input[type="number"] {
                width: 100%;
                max-width: 120px;
            }
        }
    </style>
</head>
<body>
    <a href="#main-content" class="skip-link">Skip to main content</a>
    
    <div class="container">
        <div class="header">
            <h1>FINAL PACK LINE OPTIMIZER</h1>
            <p>Maximize Tolerance Across Multiple Scales</p>
        </div>
        
        <main id="main-content">
            <div class="section">
                <h2>PROJECT SETTINGS</h2>
                
                <div class="project-field">
                    <label for="projectName">Product Name:</label>
                    <input type="text" id="projectName" value=" " placeholder="Enter product name">
                </div>
                
                <div>
                    <label for="numScales">Number of Scales:</label>
                    <select id="numScales">
                        <option value="2" selected>2 Scales</option>
                        <option value="3">3 Scales</option>
                        <option value="4">4 Scales</option>
                        <option value="5">5 Scales</option>
                    </select>
                    <span style="margin-left: 15px;">
                        Current: <strong id="currentScaleCount">2</strong> Scales
                    </span>
                </div>

                <div class="min-tolerance-section">
                    <h3 style="margin-top: 0; color: #2c3e50;">MINIMUM TOLERANCE REQUIREMENTS</h3>
                    <div class="info">
                        <strong>HOW IT WORKS:</strong>
                        <ul style="margin: 8px 0; padding-left: 20px;">
                            <li>Set minimum tolerance values that each scale must achieve</li>
                            <li>During optimization, assignments that don't meet minimums are rejected</li>
                            <li><strong>Default is 0 (no minimum requirements)</strong></li>
                            <li>Cards show green borders when minimums are met, red borders when not</li>
                        </ul>
                    </div>
                    <div id="minToleranceContainer" class="min-tolerance-grid">
                        <!-- Will be populated by JavaScript -->
                    </div>
                    <div style="margin-top: 15px; padding: 10px; background: #e8f4f8; border-radius: 6px;">
                        <strong>Current Settings:</strong> <span id="minToleranceStatus">Loading...</span>
                    </div>
                </div>
            </div>

            <div class="section">
                <h2>ITEM MANAGEMENT</h2>
                
                <div class="controls">
                    <button class="success-btn" id="addItemBtn">Add Item</button>
                    <button id="removeItemBtn">Remove Item</button>
                    <button id="loadSampleBtn">Load Sample Data</button>
                    <button id="clearAllBtn">Clear All</button>
                    <button id="lockAllBtn" style="background: #f39c12;">Lock All</button>
                    <button id="unlockAllBtn" style="background: #95a5a6;">Unlock All</button>
                </div>
                
                <div style="margin: 10px 0; padding: 10px; background: #e8f4f8; border-radius: 4px;">
                    <strong>PRODUCTION RUN:</strong> 
                    <span id="debugInfo">Items: 0, Scales: 2</span>
                </div>
                
                <div id="validationMessages"></div>
                
                <table id="itemTable">
                    <thead>
                        <tr id="tableHeader">
                            <th>Item Name</th>
                            <th>Weight (grams)</th>
                            <th class="scale-header">Scale 1</th>
                            <th class="scale-header">Scale 2</th>
                            <th>Lock</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody id="itemTableBody">
                        <!-- Item rows will be inserted here -->
                    </tbody>
                </table>
            </div>

            <div class="section">
                <h2>OPTIMIZATION</h2>
                
                <div class="optimization-strategy">
                    <h3 style="margin-top: 0; color: #2c3e50;">Optimization Strategy:</h3>
                    
                    <div class="strategy-option">
                        <label>
                            <input type="radio" name="optimizationMode" value="balanced" checked>
                            Balanced (Sum of all tolerances)
                        </label>
                        <div class="strategy-description">
                            Maximizes the total sum of all scale tolerances. Best when all scales are equally important.
                        </div>
                    </div>
                    
                    <div class="strategy-option">
                        <label>
                            <input type="radio" name="optimizationMode" value="product">
                            Product (Product of all tolerances)
                        </label>
                        <div class="strategy-description">
                            Maximizes the product of all tolerances. Ensures no scale performs very poorly, as any zero tolerance makes the product zero.
                        </div>
                    </div>
                    
                    <div class="strategy-option">
                        <label>
                            <input type="radio" name="optimizationMode" value="min">
                            Min-Max (Maximum minimum tolerance)
                        </label>
                        <div class="strategy-description">
                            Maximizes the worst-performing scale's tolerance. Best for ensuring all scales meet minimum performance standards.
                        </div>
                    </div>
                </div>
                
                <div class="controls">
                    <button class="success-btn" id="calculateBtn">Calculate Tolerances</button>
                    <button class="optimize-btn" id="optimizeBtn">OPTIMIZE ALL SCALES</button>
                    <button id="resetBtn">Reset Assignment</button>
                </div>
                
                <div id="optimizationProgress" style="display: none;">
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill"></div>
                    </div>
                    <p id="progressText">Optimizing...</p>
                </div>
            </div>

            <div class="section" id="optimizationResults" style="display: none;">
                <h2>OPTIMIZATION RESULTS</h2>
                
                <div class="controls">
                    <button id="clearResultsBtn" style="background: #95a5a6;">Clear Results</button>
                    <button id="compareResultsBtn" style="background: #9b59b6;">Compare with Previous</button>
                </div>
                
                <div id="optimizationResultsContent">
                    <!-- Results will be populated here -->
                </div>
            </div>

            <div class="section">
                <h2>TOLERANCE RESULTS</h2>
                <div id="toleranceCards" class="tolerance-cards">
                    <!-- Tolerance cards will be generated here -->
                </div>
            </div>

            <div class="section">
                <h2>EXPORT</h2>
                <div class="controls">
                    <button class="success-btn" id="exportCSVBtn">Export CSV</button>
                    <button id="exportReportBtn">Export Report</button>
                </div>
            </div>
        </main>
    </div>

    <script>
        class ToleranceOptimizer {
            constructor() {
                this.items = [];
                this.numScales = 2;
                this.projectName = ' '
                this.minTolerances = [0.0, 0.0, 0.0, 0.0, 0.0];
                this.scaleColors = ['#3498db', '#e74c3c', '#27ae60', '#f39c12', '#9b59b6'];
                this.isOptimizing = false;
                this.debounceTimeouts = new Map();
                this.lockedItems = new Set();
                this.optimizationHistory = [];
                this.currentOptimizationResult = null;
            }

            initializeApp() {
                console.log("Initializing app...");
                this.addEventListeners();
                this.createMinToleranceControls();
                this.loadSampleData();
                this.updateUI();
                console.log("App initialized successfully");
            }

            addEventListeners() {
                document.getElementById('addItemBtn').addEventListener('click', () => this.addItem());
                document.getElementById('removeItemBtn').addEventListener('click', () => this.removeItem());
                document.getElementById('loadSampleBtn').addEventListener('click', () => this.loadSampleData());
                document.getElementById('clearAllBtn').addEventListener('click', () => this.clearAll());
                document.getElementById('optimizeBtn').addEventListener('click', () => this.optimizeAssignments());
                document.getElementById('calculateBtn').addEventListener('click', () => this.calculateTolerances());
                document.getElementById('resetBtn').addEventListener('click', () => this.resetAssignments());
                document.getElementById('lockAllBtn').addEventListener('click', () => this.lockAllItems());
                document.getElementById('unlockAllBtn').addEventListener('click', () => this.unlockAllItems());
                document.getElementById('exportCSVBtn').addEventListener('click', () => this.exportToCSV());
                document.getElementById('exportReportBtn').addEventListener('click', () => this.exportReport());
                document.getElementById('numScales').addEventListener('change', (e) => this.updateScaleCount(e.target.value));
                document.getElementById('projectName').addEventListener('input', (e) => this.debounce('projectName', () => this.updateProjectName(e.target.value), 500));
                
                // Safely add event listeners for buttons that may not exist initially
                const clearResultsBtn = document.getElementById('clearResultsBtn');
                if (clearResultsBtn) {
                    clearResultsBtn.addEventListener('click', () => this.clearOptimizationResults());
                }
                
                const compareResultsBtn = document.getElementById('compareResultsBtn');
                if (compareResultsBtn) {
                    compareResultsBtn.addEventListener('click', () => this.compareResults());
                }
            }

            debounce(key, func, delay) {
                if (this.debounceTimeouts.has(key)) {
                    clearTimeout(this.debounceTimeouts.get(key));
                }
                const timeoutId = setTimeout(func, delay);
                this.debounceTimeouts.set(key, timeoutId);
            }

            createMinToleranceControls() {
                const container = document.getElementById('minToleranceContainer');
                if (!container) return;
                
                container.innerHTML = '';
                
                for (let i = 0; i < this.numScales; i++) {
                    const item = document.createElement('div');
                    item.className = 'min-tolerance-item';
                    
                    const scaleColor = this.scaleColors[i] || '#666';
                    this.minTolerances[i] = 0.0;
                    
                    item.innerHTML = `
                        <label for="minTolerance${i}" style="font-weight: bold; color: ${scaleColor}; font-size: 16px; display: block;">
                            Scale ${i + 1} : Minimum Tolerance
                        </label>
                        <input type="number" id="minTolerance${i}" class="min-tolerance-input" 
                               value="0" min="0" step="0.1" 
                               onchange="optimizer.setMinTolerance(${i}, this.value)">
                        <small style="color: #666; margin-top: 5px; display: block;">
                            Current tolerance: <span id="current${i}" style="font-weight: bold;">0.00</span>
                        </small>
                    `;
                    
                    container.appendChild(item);
                }
                
                this.updateMinToleranceStatus();
            }

            setMinTolerance(scaleIndex, value) {
                const numValue = parseFloat(value) || 0.0;
                if (numValue < 0) {
                    this.showMessage("Minimum tolerance cannot be negative", "error");
                    document.getElementById(`minTolerance${scaleIndex}`).value = this.minTolerances[scaleIndex];
                    return;
                }
                this.minTolerances[scaleIndex] = numValue;
                this.updateMinToleranceStatus();
                this.debounce('toleranceUpdate', () => this.renderToleranceCards(), 300);
            }

            updateMinToleranceStatus() {
                const statusElement = document.getElementById('minToleranceStatus');
                if (statusElement) {
                    const statusText = [];
                    for (let i = 0; i < this.numScales; i++) {
                        statusText.push(`Scale ${i + 1}: ${(this.minTolerances[i] || 0.0).toFixed(2)}`);
                    }
                    statusElement.textContent = statusText.join(' | ');
                }
            }

            calculateMinDifference(weights) {
                if (weights.length < 2) return 0;
                let minDiff = Infinity;
                
                for (let i = 0; i < weights.length; i++) {
                    for (let j = i + 1; j < weights.length; j++) {
                        const diff = Math.abs(weights[i] - weights[j]);
                        if (diff > 0 && diff < minDiff) {
                            minDiff = diff;
                        }
                    }
                }
                return minDiff === Infinity ? 0 : minDiff;
            }

            calculateScaleTolerance(weights) {
                if (weights.length < 2) {
                    return {
                        minWeight: 0,
                        minDiff: 0,
                        factorA: 0,
                        factorB: 0,
                        tolerance: 0
                    };
                }
                
                const minWeight = Math.min(...weights);
                const minDiff = this.calculateMinDifference(weights);
                const factorA = minWeight / 3;
                const factorB = minDiff * 2 / 3;
                const tolerance = Math.min(factorA, factorB);
                
                return {
                    minWeight,
                    minDiff,
                    factorA,
                    factorB,
                    tolerance
                };
            }

            renderToleranceCards() {
                const container = document.getElementById('toleranceCards');
                if (!container) return;
                
                container.innerHTML = '';
                
                for (let i = 1; i <= this.numScales; i++) {
                    const scaleWeights = this.items.filter(item => item[`scale${i}`]).map(item => item.weight);
                    const results = this.calculateScaleTolerance(scaleWeights);
                    const minRequired = this.minTolerances[i - 1] || 0.0;
                    const meetsMinimum = results.tolerance >= minRequired;
                    
                    const currentSpan = document.getElementById(`current${i - 1}`);
                    if (currentSpan) {
                        const displayValue = results.tolerance === 0 ? '0' : results.tolerance.toFixed(2);
                        currentSpan.textContent = displayValue;
                        currentSpan.style.color = meetsMinimum && minRequired > 0 ? '#27ae60' : '#e74c3c';
                    }
                    
                    const card = document.createElement('div');
                    card.className = 'scale-card';
                    
                    if (minRequired > 0) {
                        card.style.border = `3px solid ${meetsMinimum ? '#27ae60' : '#e74c3c'}`;
                    }
                    
                    const statusIndicator = minRequired > 0 ? 
                        `<span class="status-indicator ${meetsMinimum ? 'status-success' : 'status-error'}"></span>` : '';
                    
                    card.innerHTML = `
                        <h3 style="color: ${this.scaleColors[i-1] || '#666'}">Scale ${i}</h3>
                        <div class="metric">
                            <span>Assigned Items:</span>
                            <span><strong>${scaleWeights.length}</strong></span>
                        </div>
                        <div class="metric">
                            <span>Smallest Weight:</span>
                            <span>${results.minWeight.toFixed(2)}g</span>
                        </div>
                        <div class="metric">
                            <span>Smallest Difference:</span>
                            <span>${results.minDiff.toFixed(2)}g</span>
                        </div>
                        <div class="metric">
                            <span>Factor A (1/3 × Min Weight):</span>
                            <span>${results.factorA.toFixed(2)}</span>
                        </div>
                        <div class="metric">
                            <span>Factor B (2/3 × Min Diff):</span>
                            <span>${results.factorB.toFixed(2)}</span>
                        </div>
                        ${minRequired > 0 ? 
                            `<div class="metric" style="background: ${meetsMinimum ? '#27ae60' : '#e74c3c'}; color: white; margin: 5px -20px; padding: 8px 20px; border-radius: 4px;">
                                <span><strong>Min Required:</strong></span>
                                <span><strong>${minRequired.toFixed(2)}</strong></span>
                            </div>` : ''}
                        <div class="metric" style="background: ${this.scaleColors[i-1] || '#666'}; color: white; margin: 10px -20px -20px -20px; padding: 12px 20px; border-radius: 0 0 8px 8px;">
                            <span><strong>TOLERANCE:</strong></span>
                            <span><strong>${results.tolerance.toFixed(2)} ${statusIndicator}</strong></span>
                        </div>
                    `;
                    
                    container.appendChild(card);
                }
            }

            updateProjectName(name) {
                this.projectName = name.trim() || ' ';
                this.projectName = this.projectName.replace(/[<>:"/\\|?*]/g, '_');
            }

            updateScaleCount(value) {
                const newScaleCount = parseInt(value);
                if (newScaleCount < 2 || newScaleCount > 5) {
                    this.showMessage("Number of scales must be between 2 and 5", "error");
                    return;
                }

                this.numScales = newScaleCount;
                document.getElementById('currentScaleCount').textContent = this.numScales;
                
                this.items.forEach((item, index) => {
                    for (let i = 1; i <= 5; i++) {
                        delete item[`scale${i}`];
                    }
                    for (let i = 1; i <= this.numScales; i++) {
                        item[`scale${i}`] = i === ((index % this.numScales) + 1);
                    }
                });
                
                this.updateTableHeaders();
                this.createMinToleranceControls();
                this.updateUI();
            }

            updateTableHeaders() {
                const headerRow = document.getElementById('tableHeader');
                const scaleHeaders = headerRow.querySelectorAll('.scale-header');
                scaleHeaders.forEach(header => header.remove());
                
                const lockHeader = headerRow.children[headerRow.children.length - 2];
                const actionsHeader = headerRow.lastElementChild;
                for (let i = 1; i <= this.numScales; i++) {
                    const th = document.createElement('th');
                    th.className = 'scale-header';
                    th.textContent = `Scale ${i}`;
                    headerRow.insertBefore(th, lockHeader);
                }
            }

            addItem() {
                const newItem = { 
                    name: `Item ${this.items.length + 1}`,
                    weight: 1000 + Math.floor(Math.random() * 100)
                };
                
                const scaleCounts = new Array(this.numScales).fill(0);
                this.items.forEach(item => {
                    for (let i = 1; i <= this.numScales; i++) {
                        if (item[`scale${i}`]) {
                            scaleCounts[i - 1]++;
                            break;
                        }
                    }
                });
                
                const minCountIndex = scaleCounts.indexOf(Math.min(...scaleCounts));
                for (let i = 1; i <= this.numScales; i++) {
                    newItem[`scale${i}`] = i === (minCountIndex + 1);
                }
                
                this.items.push(newItem);
                this.updateUI();
                this.showMessage("Item added successfully", "info");
            }

            removeItem() {
                if (this.items.length > 0) {
                    this.items.pop();
                    const newLockedItems = new Set();
                    for (const lockedIndex of this.lockedItems) {
                        if (lockedIndex < this.items.length) {
                            newLockedItems.add(lockedIndex);
                        }
                    }
                    this.lockedItems = newLockedItems;
                    this.updateUI();
                    this.showMessage("Item removed successfully", "info");
                } else {
                    this.showMessage("No items to remove", "warning");
                }
            }

            clearAll() {
                if (this.items.length === 0) {
                    this.showMessage("No items to clear", "warning");
                    return;
                }
                
                if (confirm("Clear all items? This action cannot be undone.")) {
                    this.items = [];
                    this.lockedItems.clear();
                    this.updateUI();
                    this.showMessage("All items cleared successfully", "info");
                }
            }

            loadSampleData() {
                this.items = [];
                this.lockedItems.clear();
                const sampleWeights = [84.8, 42.06, 33.749, 18.453, 8.485, 5.12, 6.571, 32.536];
		        const sampleNames = ["BI", "6544401", "6537259", "6544400", "6537257","4656764","6537260","654399"];
                
                sampleWeights.forEach((weight, index) => {
                    const bag = { 
                        name:sampleNames[index],
                        weight: weight 
                    };
                    item[`scale${((index % this.numScales) + 1)}`] = true;
                    this.items.push(item);
                });
                
                this.updateUI();
                this.showMessage("Sample data loaded successfully", "info");
            }

            updateUI() {
                console.log("updateUI called - rendering table, tolerance cards, and debug info");
                console.log("Current items:", this.items.length);
                console.log("Items data:", this.items);
                
                try {
                    console.log("About to call renderTable()");
                    this.renderTable();
                    console.log("renderTable() completed");
                } catch (error) {
                    console.error("Error in renderTable():", error);
                }
                
                try {
                    console.log("About to call renderToleranceCardsNew()");
                    this.renderToleranceCardsNew();
                    console.log("renderToleranceCardsNew() completed");
                } catch (error) {
                    console.error("Error in renderToleranceCardsNew():", error);
                }
                
                try {
                    console.log("About to call updateDebugInfo()");
                    this.updateDebugInfo();
                    console.log("updateDebugInfo() completed");
                } catch (error) {
                    console.error("Error in updateDebugInfo():", error);
                }
                
                console.log("updateUI complete");
            }

            renderToleranceCardsNew() {
                console.log("*** RENDERING TOLERANCE CARDS ***");
                
                const container = document.getElementById('toleranceCards');
                if (!container) {
                    console.log("No container found");
                    return;
                }
                
                console.log("Container found, clearing content");
                container.innerHTML = '';
                
                for (let i = 1; i <= this.numScales; i++) {
                    console.log(`Processing scale ${i}`);
                    
                    const scaleItems = this.items.filter(item => item[`scale${i}`]);
                    const scaleWeights = scaleItems.map(item => item.weight);
                    const results = this.calculateScaleTolerance(scaleWeights);
                    const minRequired = this.minTolerances[i - 1] || 0.0;
                    const meetsMinimum = results.tolerance >= minRequired;
                    
                    console.log(`Scale ${i} has ${scaleItems.length} items:`, scaleItems.map(item => item.name));
                    
                    // Update current tolerance display in minimum tolerance section
                    const currentSpan = document.getElementById(`current${i - 1}`);
                    if (currentSpan) {
                        const displayValue = results.tolerance === 0 ? '0' : results.tolerance.toFixed(2);
                        currentSpan.textContent = displayValue;
                        currentSpan.style.color = meetsMinimum && minRequired > 0 ? '#27ae60' : '#e74c3c';
                    }
                    
                    const card = document.createElement('div');
                    card.className = 'scale-card';
                    
                    if (minRequired > 0) {
                        card.style.border = `3px solid ${meetsMinimum ? '#27ae60' : '#e74c3c'}`;
                    }
                    
                    const statusIndicator = minRequired > 0 ? 
                        `<span class="status-indicator ${meetsMinimum ? 'status-success' : 'status-error'}"></span>` : '';
                    
                    const itemList = scaleItems.length > 0 ? 
                        scaleItems.map(item => `${item.name} (${item.weight}g)`).join(', ') : 
                        'No items assigned';
                    
                    console.log(`Scale ${i} item list: ${itemList}`);
                    
                    card.innerHTML = `
                        <h3 style="color: ${this.scaleColors[i-1] || '#666'}">Scale ${i}</h3>
                        <div class="metric">
                            <span>Assigned Items:</span>
                            <span><strong>${scaleItems.length}</strong></span>
                        </div>
                        <div style="margin: 10px 0; padding: 10px; background: #f8f9fa; border-radius: 4px; border-left: 4px solid ${this.scaleColors[i-1] || '#666'}; min-height: 50px;">
                            <strong style="display: block; margin-bottom: 5px; color: ${this.scaleColors[i-1] || '#666'};">Items:</strong>
                            <div style="font-size: 13px; line-height: 1.4; max-height: 80px; overflow-y: auto; word-wrap: break-word;">${itemList}</div>
                        </div>
                        <div class="metric">
                            <span>Smallest Weight:</span>
                            <span>${results.minWeight.toFixed(2)}g</span>
                        </div>
                        <div class="metric">
                            <span>Smallest Difference:</span>
                            <span>${results.minDiff.toFixed(2)}g</span>
                        </div>
                        <div class="metric">
                            <span>Factor A (1/3 × Min Weight):</span>
                            <span>${results.factorA.toFixed(2)}</span>
                        </div>
                        <div class="metric">
                            <span>Factor B (2/3 × Min Diff):</span>
                            <span>${results.factorB.toFixed(2)}</span>
                        </div>
                        ${minRequired > 0 ? 
                            `<div class="metric" style="background: ${meetsMinimum ? '#27ae60' : '#e74c3c'}; color: white; margin: 5px -20px; padding: 8px 20px; border-radius: 4px;">
                                <span><strong>Min Required:</strong></span>
                                <span><strong>${minRequired.toFixed(2)}</strong></span>
                            </div>` : ''}
                        <div class="metric" style="background: ${this.scaleColors[i-1] || '#666'}; color: white; margin: 10px -20px -20px -20px; padding: 12px 20px; border-radius: 0 0 8px 8px;">
                            <span><strong>TOLERANCE:</strong></span>
                            <span><strong>${results.tolerance.toFixed(2)} ${statusIndicator}</strong></span>
                        </div>
                    `;
                    
                    container.appendChild(card);
                    console.log(`Scale ${i} card added`);
                }
                
                console.log("All tolerance cards rendered successfully");
            }

            updateDebugInfo() {
                const debugElement = document.getElementById('debugInfo');
                if (debugElement) {
                    debugElement.textContent = `Items: ${this.items.length}, Scales: ${this.numScales}`;
                }
            }

            renderTable() {
                const tbody = document.getElementById('itemTableBody');
                if (!tbody) return;
                
                tbody.innerHTML = '';
                
                this.items.forEach((item, index) => {
                    const row = document.createElement('tr');
                    
                    if (this.lockedItems.has(index)) {
                        row.classList.add('locked-row');
                    }
                    
                    let html = `
                        <td><input type="text" value="${this.escapeHtml(item.name)}" onchange="optimizer.updateItemName(${index}, this.value)"></td>
                        <td><input type="number" value="${item.weight}" min="0" step="1" onchange="optimizer.updateWeight(${index}, this.value)"></td>
                    `;
                    
                    for (let i = 1; i <= this.numScales; i++) {
                        const isLocked = this.lockedItems.has(index);
                        html += `<td><input type="checkbox" ${item[`scale${i}`] ? 'checked' : ''} ${isLocked ? 'disabled' : ''} onchange="optimizer.updateAssignment(${index}, ${i}, this.checked)"></td>`;
                    }
                    
                    const isLocked = this.lockedItems.has(index);
                    html += `
                        <td><button class="lock-button ${isLocked ? 'locked' : 'unlocked'}" onclick="optimizer.toggleItemLock(${index})">${isLocked ? 'Locked' : 'Unlocked'}</button></td>
                        <td><button onclick="optimizer.deleteItem(${index})" style="background: #e74c3c; color: white; padding: 5px 10px; border: none; border-radius: 4px; cursor: pointer;">Delete</button></td>
                    `;
                    
                    row.innerHTML = html;
                    tbody.appendChild(row);
                });
            }

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            updateItemName(index, newName) {
                if (newName.trim()) {
                    this.items[index].name = newName.trim();
                }
            }

            updateWeight(index, value) {
                const weight = parseFloat(value);
                if (!isNaN(weight) && weight >= 0) {
                    this.items[index].weight = weight;
                    this.debounce('weightUpdate', () => this.renderToleranceCards(), 300);
                }
            }

            updateAssignment(index, scaleNum, checked) {
                if (this.lockedItems.has(index)) {
                    this.showMessage(`Item "${this.items[index].name}" is locked and cannot be reassigned`, "warning");
                    return;
                }
                
                if (checked) {
                    for (let i = 1; i <= this.numScales; i++) {
                        this.items[index][`scale${i}`] = i === scaleNum;
                    }
                } else {
                    this.items[index][`scale${scaleNum}`] = false;
                    
                    let assignedToAny = false;
                    for (let i = 1; i <= this.numScales; i++) {
                        if (this.items[index][`scale${i}`]) {
                            assignedToAny = true;
                            break;
                        }
                    }
                    
                    if (!assignedToAny) {
                        this.items[index].scale1 = true;
                    }
                }
                
                this.debounce('assignmentUpdate', () => this.updateUI(), 300);
            }

            deleteItem(index) {
                if (confirm(`Delete item "${this.items[index].name}"?`)) {
                    this.items.splice(index, 1);
                    
                    const newLockedItems = new Set();
                    for (const lockedIndex of this.lockedItems) {
                        if (lockedIndex < index) {
                            newLockedItems.add(lockedIndex);
                        } else if (lockedIndex > index) {
                            newLockedItems.add(lockedIndex - 1);
                        }
                    }
                    this.lockedItems = newLockedItems;
                    
                    this.updateUI();
                    this.showMessage("Item deleted successfully", "info");
                }
            }

            toggleItemLock(index) {
                if (this.lockedItems.has(index)) {
                    this.lockedItems.delete(index);
                    this.showMessage(`Item "${this.items[index].name}" unlocked`, "info");
                } else {
                    this.lockedItems.add(index);
                    this.showMessage(`Item "${this.items[index].name}" locked`, "info");
                }
                this.updateUI();
            }

            lockAllItems() {
                if (this.items.length === 0) {
                    this.showMessage("No items to lock", "warning");
                    return;
                }
                
                for (let i = 0; i < this.items.length; i++) {
                    this.lockedItems.add(i);
                }
                this.updateUI();
                this.showMessage(`All ${this.items.length} items locked`, "info");
            }

            unlockAllItems() {
                const lockedCount = this.lockedItems.size;
                if (lockedCount === 0) {
                    this.showMessage("No items are currently locked", "warning");
                    return;
                }
                
                this.lockedItems.clear();
                this.updateUI();
                this.showMessage(`All ${lockedCount} items unlocked`, "info");
            }

            calculateTolerances() {
                this.renderToleranceCards();
                this.showMessage("Tolerances calculated successfully", "info");
            }

            resetAssignments() {
                if (this.items.length === 0) {
                    this.showMessage("No items to reset", "warning");
                    return;
                }

                if (confirm("Reset all item assignments to default distribution?")) {
                    this.items.forEach((item, index) => {
                        for (let i = 1; i <= this.numScales; i++) {
                            item[`scale${i}`] = i === ((index % this.numScales) + 1);
                        }
                    });
                    
                    this.updateUI();
                    this.showMessage("Assignments reset successfully", "info");
                }
            }

            async optimizeAssignments() {
                if (this.isOptimizing) {
                    this.showMessage("Optimization already in progress", "warning");
                    return;
                }

                if (this.items.length === 0) {
                    this.showMessage('Need at least 1 item for optimization', 'error');
                    return;
                }

                this.isOptimizing = true;
                this.showOptimizationProgress(true);
                
                try {
                    const mode = document.querySelector('input[name="optimizationMode"]:checked').value;
                    
                    // Simple optimization for demo - distribute items evenly and then improve
                    this.items.forEach((item, index) => {
                        if (!this.lockedItems.has(index)) {
                            for (let i = 1; i <= this.numScales; i++) {
                                item[`scale${i}`] = i === ((index % this.numScales) + 1);
                            }
                        }
                    });
                    
                    // Simulate progress
                    for (let i = 0; i <= 100; i += 10) {
                        this.updateProgress(i);
                        await new Promise(resolve => setTimeout(resolve, 50));
                    }
                    
                    this.updateUI();
                    this.showOptimizationResults(mode);
                    
                } catch (error) {
                    console.error("Optimization error:", error);
                    this.showMessage("Error during optimization: " + error.message, "error");
                } finally {
                    this.isOptimizing = false;
                    this.showOptimizationProgress(false);
                }
            }

            showOptimizationProgress(show) {
                const progressDiv = document.getElementById('optimizationProgress');
                const optimizeBtn = document.getElementById('optimizeBtn');
                
                if (progressDiv) {
                    progressDiv.style.display = show ? 'block' : 'none';
                }
                
                if (optimizeBtn) {
                    optimizeBtn.disabled = show;
                    optimizeBtn.textContent = show ? 'OPTIMIZING...' : 'OPTIMIZE ALL SCALES';
                }
            }

            updateProgress(percentage) {
                const progressFill = document.getElementById('progressFill');
                const progressText = document.getElementById('progressText');
                
                if (progressFill) {
                    progressFill.style.width = percentage + '%';
                }
                
                if (progressText) {
                    progressText.textContent = `Optimizing... ${Math.round(percentage)}%`;
                }
            }

            showOptimizationResults(mode) {
                let totalTolerance = 0;
                let toleranceDetails = [];
                let lockedItemsCount = this.lockedItems.size;
                let productTolerance = 1;
                let minTolerance = Infinity;
                
                for (let i = 1; i <= this.numScales; i++) {
                    const scaleWeights = this.items.filter(item => item[`scale${i}`]).map(item => item.weight);
                    const results = this.calculateScaleTolerance(scaleWeights);
                    const minRequired = this.minTolerances[i - 1] || 0.0;
                    
                    totalTolerance += results.tolerance;
                    productTolerance *= results.tolerance;
                    minTolerance = Math.min(minTolerance, results.tolerance);
                    
                    toleranceDetails.push({
                        scale: i,
                        tolerance: results.tolerance,
                        itemCount: scaleWeights.length,
                        minRequired: minRequired,
                        meetsRequirement: results.tolerance >= minRequired,
                        color: this.scaleColors[i - 1] || '#666'
                    });
                }
                
                if (minTolerance === Infinity) minTolerance = 0;
                
                // Store current result
                this.currentOptimizationResult = {
                    timestamp: new Date(),
                    mode: mode,
                    totalTolerance: totalTolerance,
                    productTolerance: productTolerance,
                    minTolerance: minTolerance,
                    toleranceDetails: toleranceDetails,
                    lockedItemsCount: lockedItemsCount,
                    totalItems: this.items.length
                };
                
                // Add to history
                this.optimizationHistory.push({...this.currentOptimizationResult});
                
                // Show the results section
                document.getElementById('optimizationResults').style.display = 'block';
                
                // Render the results
                this.renderOptimizationResults();
                
                // Scroll to results
                document.getElementById('optimizationResults').scrollIntoView({ 
                    behavior: 'smooth', 
                    block: 'start' 
                });
            }

            renderOptimizationResults() {
                const container = document.getElementById('optimizationResultsContent');
                if (!container || !this.currentOptimizationResult) return;
                
                const result = this.currentOptimizationResult;
                const modeNames = {
                    'balanced': 'Balanced (Sum)',
                    'product': 'Product',
                    'min': 'Min-Max'
                };
                
                container.innerHTML = `
                    <div class="optimization-results-card">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                            <h3 style="margin: 0; font-size: 24px;">Optimization Complete</h3>
                            <span style="background: rgba(255,255,255,0.2); padding: 8px 16px; border-radius: 20px; font-size: 14px;">
                                ${modeNames[result.mode]} Strategy
                            </span>
                        </div>
                        
                        <div class="optimization-summary">
                            <div class="summary-metric">
                                <h4>Sum of Tolerance</h4>
                                <div class="value">${result.totalTolerance.toFixed(2)}</div>
                            </div>
                            <div class="summary-metric">
                                <h4>Product of Tolerance</h4>
                                <div class="value">${result.productTolerance.toFixed(3)}</div>
                            </div>
                            <div class="summary-metric">
                                <h4>Minimum Scale Weight</h4>
                                <div class="value">${result.minTolerance.toFixed(3)}</div>
                            </div>
                            <div class="summary-metric">
                                <h4>Total Items Packed</h4>
                                <div class="value">${result.totalItems}</div>
                                ${result.lockedItemsCount > 0 ? `<small>${result.lockedItemsCount} locked</small>` : ''}
                            </div>
                        </div>
                        
                        <div class="optimization-timestamp">
                            Completed: ${result.timestamp.toLocaleString()}
                        </div>
                    </div>
                    
                    <div class="scale-breakdown">
                        <h4 style="margin-top: 0; color: #2c3e50; border-bottom: 2px solid #ecf0f1; padding-bottom: 10px;">
                            Scale Performance Breakdown
                        </h4>
                        ${result.toleranceDetails.map(scale => `
                            <div class="scale-row">
                                <div class="scale-name" style="color: ${scale.color};">
                                    Scale ${scale.scale} (${scale.itemCount} items)
                                </div>
                                <div class="scale-details">
                                    ${scale.minRequired > 0 ? `
                                        <span class="min-req-status ${scale.meetsRequirement ? 'req-met' : 'req-not-met'}">
                                            Min: ${scale.minRequired.toFixed(2)} ${scale.meetsRequirement ? '✓' : '✗'}
                                        </span>
                                    ` : ''}
                                    <div class="tolerance-value" style="background: ${scale.color}; color: white;">
                                        ${scale.tolerance.toFixed(3)}
                                    </div>
                                </div>
                            </div>
                        `).join('')}
                        
                        <div class="results-actions">
                            <button onclick="optimizer.saveOptimizationSnapshot()" style="background: #27ae60; color: white; padding: 8px 16px; border: none; border-radius: 4px; cursor: pointer;">
                                Save Snapshot
                            </button>
                            <button onclick="optimizer.exportOptimizationReport()" style="background: #3498db; color: white; padding: 8px 16px; border: none; border-radius: 4px; cursor: pointer;">
                                Export Detailed Report
                            </button>
                        </div>
                    </div>
                `;
            }

            clearOptimizationResults() {
                document.getElementById('optimizationResults').style.display = 'none';
                this.currentOptimizationResult = null;
                this.showMessage("Optimization results cleared", "info");
            }

            compareResults() {
                if (this.optimizationHistory.length < 2) {
                    this.showMessage("Need at least 2 optimization runs to compare results", "warning");
                    return;
                }
                
                const current = this.optimizationHistory[this.optimizationHistory.length - 1];
                const previous = this.optimizationHistory[this.optimizationHistory.length - 2];
                
                const improvement = current.totalTolerance - previous.totalTolerance;
                const percentChange = ((improvement / previous.totalTolerance) * 100).toFixed(2);
                
                this.showMessage(`Comparison with previous run:<br>
                    Total tolerance change: ${improvement > 0 ? '+' : ''}${improvement.toFixed(3)} (${percentChange}%)<br>
                    Previous: ${previous.totalTolerance.toFixed(3)} | Current: ${current.totalTolerance.toFixed(3)}`, "info");
            }

            saveOptimizationSnapshot() {
                if (!this.currentOptimizationResult) {
                    this.showMessage("No optimization result to save", "warning");
                    return;
                }
                
                const snapshot = {
                    project: this.projectName,
                    ...this.currentOptimizationResult,
                    items: JSON.parse(JSON.stringify(this.items)),
                    minTolerances: [...this.minTolerances]
                };
                
                const filename = `${this.projectName}_optimization_snapshot_${new Date().toISOString().slice(0,19).replace(/:/g, '-')}.json`;
                this.downloadFile(JSON.stringify(snapshot, null, 2), filename, 'application/json');
                this.showMessage("Optimization snapshot saved successfully", "result");
            }

            exportOptimizationReport() {
                if (!this.currentOptimizationResult) {
                    this.showMessage("No optimization result to export", "warning");
                    return;
                }
                
                // Use the existing exportReport method but with optimization context
                this.exportReport();
            }

            showMessage(message, type) {
                // For optimization results, don't use the temporary message system
                if (type === 'result' && this.currentOptimizationResult) {
                    return; // Results are now shown in dedicated section
                }
                
                // Create a temporary message container if it doesn't exist
                let messageContainer = document.getElementById('tempMessageContainer');
                if (!messageContainer) {
                    messageContainer = document.createElement('div');
                    messageContainer.id = 'tempMessageContainer';
                    messageContainer.style.cssText = `
                        position: fixed;
                        top: 20px;
                        right: 20px;
                        z-index: 1000;
                        max-width: 400px;
                    `;
                    document.body.appendChild(messageContainer);
                }
                
                const className = type === "warning" ? 'warning' : type === "error" ? 'error' : type === "info" ? 'info' : 'result';
                
                const messageDiv = document.createElement('div');
                messageDiv.className = className;
                messageDiv.style.cssText = `
                    margin-bottom: 10px;
                    padding: 15px;
                    border-radius: 5px;
                    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                    animation: slideIn 0.3s ease-out;
                `;
                messageDiv.innerHTML = message;
                
                // Add animation styles if not already present
                if (!document.getElementById('messageAnimations')) {
                    const style = document.createElement('style');
                    style.id = 'messageAnimations';
                    style.textContent = `
                        @keyframes slideIn {
                            from { transform: translateX(100%); opacity: 0; }
                            to { transform: translateX(0); opacity: 1; }
                        }
                        @keyframes slideOut {
                            from { transform: translateX(0); opacity: 1; }
                            to { transform: translateX(100%); opacity: 0; }
                        }
                    `;
                    document.head.appendChild(style);
                }
                
                messageContainer.appendChild(messageDiv);
                
                // Auto-remove after delay (except for errors)
                if (type !== "error") {
                    setTimeout(() => {
                        messageDiv.style.animation = 'slideOut 0.3s ease-in';
                        setTimeout(() => {
                            if (messageDiv.parentNode) {
                                messageDiv.parentNode.removeChild(messageDiv);
                            }
                        }, 300);
                    }, 4000);
                }
            }

            exportToCSV() {
                if (this.items.length === 0) {
                    this.showMessage('No data to export', 'error');
                    return;
                }
                
                let csv = "Pre-Pack Item Name,Weight(grams)";
                for (let i = 1; i <= this.numScales; i++) {
                    csv += `,Scale${i}`;
                }
                csv += ",Locked\n";
                
                this.items.forEach((item, index) => {
                    const escapedName = `"${item.name.replace(/"/g, '""')}"`;
                    csv += `${escapedName},${item.weight}`;
                    for (let i = 1; i <= this.numScales; i++) {
                        csv += `,${item[`scale${i}`] ? 1 : 0}`;
                    }
                    csv += `,${this.lockedItems.has(index) ? 1 : 0}\n`;
                });
                
                const filename = `${this.projectName}_item_assignments.csv`;
                this.downloadFile(csv, filename, 'text/csv');
                this.showMessage("CSV exported successfully", "result");
            }

            exportReport() {
                let totalTolerance = 0;
                let scaleDetails = [];
                
                for (let i = 1; i <= this.numScales; i++) {
                    const scaleItems = this.items.filter(item => item[`scale${i}`]);
                    const scaleWeights = scaleItems.map(item => item.weight);
                    const results = this.calculateScaleTolerance(scaleWeights);
                    const minRequired = this.minTolerances[i - 1] || 0.0;
                    
                    totalTolerance += results.tolerance;
                    scaleDetails.push({
                        scale: i,
                        itemCount: scaleWeights.length,
                        tolerance: results.tolerance,
                        minRequired: minRequired,
                        meetsRequirement: results.tolerance >= minRequired,
                        items: scaleItems
                    });
                }

                const report = `PRODUCTION LINE TOLERANCE OPTIMIZATION REPORT
=====================================
Project: ${this.projectName}
Generated: ${new Date().toLocaleString()}

CONFIGURATION:
Number of Scales: ${this.numScales}
Total Items: ${this.items.length}
Locked Items: ${this.lockedItems.size}

SCALE PERFORMANCE SUMMARY:
${scaleDetails.map(scale => 
    `Scale ${scale.scale}: ${scale.tolerance.toFixed(2)} tolerance (${scale.itemCount} items)${scale.minRequired > 0 ? ` - Min Req: ${scale.minRequired.toFixed(2)} ${scale.meetsRequirement ? '[MET]' : '[NOT MET]'}` : ''}`
).join('\n')}

Total Combined Tolerance: ${totalTolerance.toFixed(2)}

DETAILED SCALE ASSIGNMENTS:
${scaleDetails.map(scale => 
    `\nScale ${scale.scale} (Tolerance: ${scale.tolerance.toFixed(3)}):\n${scale.items.length > 0 ? 
        scale.items.map(item => {
            const lockStatus = this.lockedItems.has(this.items.indexOf(item)) ? ' [LOCKED]' : '';
            return `  • ${item.name}: ${item.weight}g${lockStatus}`;
        }).join('\n') : 
        '  • No items assigned'
    }`
).join('\n')}

COMPLETE ITEM LIST:
${this.items.map((item, index) => {
    let assignedScale = 'Unassigned';
    for (let i = 1; i <= this.numScales; i++) {
        if (item[`scale${i}`]) {
            assignedScale = `Scale ${i}`;
            break;
        }
    }
    const lockStatus = this.lockedItems.has(index) ? ' [LOCKED]' : '';
    return `${item.name}: ${item.weight}g → ${assignedScale}${lockStatus}`;
}).join('\n')}
`;
                
                const filename = `${this.projectName}_tolerance_report.txt`;
                this.downloadFile(report, filename, 'text/plain');
                this.showMessage("Detailed report exported successfully", "result");
            }

            downloadFile(content, filename, mimeType) {
                const blob = new Blob([content], { type: mimeType + ';charset=utf-8;' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = filename;
                link.style.display = 'none';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
            }
        }

        let optimizer;

        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM loaded, initializing optimizer...");
            try {
                optimizer = new ToleranceOptimizer();
                optimizer.initializeApp();
                window.optimizer = optimizer;
                console.log("Optimizer ready!");
            } catch (error) {
                console.error("Failed to initialize:", error);
                alert("Application failed to start: " + error.message);
            }
        });
    </script>
</body>
</html>
